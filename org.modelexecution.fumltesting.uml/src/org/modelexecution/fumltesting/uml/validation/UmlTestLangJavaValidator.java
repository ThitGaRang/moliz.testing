/*
 * generated by Xtext
 */
package org.modelexecution.fumltesting.uml.validation;

import java.util.ArrayList;

import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLLink;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLNodeSpecification;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLObjectSpecification;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLOrderAssertion;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLScenario;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLSimpleValue;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLStateAssertion;
import org.modelexecution.fumltesting.uml.umlTestLang.UMLTemporalOperator;
import org.modelexecution.fumltesting.uml.umlTestLang.UmlTestLangPackage;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("restriction")
public class UmlTestLangJavaValidator extends AbstractUmlTestLangJavaValidator {
	@Check
	public void checkAfterSpecified(UMLStateAssertion assertion) {
		if (assertion.getOperator() == UMLTemporalOperator.UNTIL && assertion.getUntilPoint() != null) {
			warning("Subsequent usage of UNTIL is not allowed!", UmlTestLangPackage.Literals.UML_STATE_ASSERTION__UNTIL_POINT);
		}
	}

	@Check
	public void checkUseOfJokers(UMLOrderAssertion assertion) {
		boolean subsequentJokerUsed = false;
		for (UMLNodeSpecification nodeSpecification : assertion.getOrder().getNodes()) {
			if (isStar(nodeSpecification) || isUnderscore(nodeSpecification)) {
				if (assertion.getOrder().getNodes().size() > assertion.getOrder().getNodes().indexOf(nodeSpecification) + 1) {
					int nextNodeIndex = assertion.getOrder().getNodes().indexOf(nodeSpecification) + 1;
					UMLNodeSpecification nextNode = assertion.getOrder().getNodes().get(nextNodeIndex);
					if (isStar(nextNode) || isUnderscore(nextNode))
						subsequentJokerUsed = true;
				}
			}

		}
		if (subsequentJokerUsed)
			error("Use of subsequent jokers is not allowed!", UmlTestLangPackage.Literals.UML_ORDER_ASSERTION__ORDER);
	}

	@Check
	public void checkObjectNames(UMLScenario scenario) {
		ArrayList<String> names = new ArrayList<String>();
		for (UMLObjectSpecification specification : scenario.getObjects()) {
			if (names.contains(specification.getName())) {
				error("Objects must have unique names!", UmlTestLangPackage.Literals.UML_SCENARIO__NAME);
			} else {
				names.add(specification.getName());
			}
		}
	}

	@Check
	public void checkLinkEnds(UMLLink link) {
		if (link.getSourceProperty() == link.getTargetProperty()) {
			error("Same source and target specified!", UmlTestLangPackage.Literals.UML_LINK__ASSOC);
		}
	}

	@Check
	public void checkMinusAllowed(UMLSimpleValue value) {
		if (!(value.getValue() instanceof XNumberLiteral) && value.isNegative()) {
			error("Minus is allowed only for integer values!", UmlTestLangPackage.Literals.UML_SIMPLE_VALUE__VALUE);
		}
	}

	private boolean isStar(UMLNodeSpecification nodeSpecification) {
		if (nodeSpecification.getJoker() != null && nodeSpecification.getJoker().equals("*"))
			return true;
		return false;
	}

	private boolean isUnderscore(UMLNodeSpecification nodeSpecification) {
		if (nodeSpecification.getJoker() != null && nodeSpecification.getJoker().equals("_"))
			return true;
		return false;
	}
}